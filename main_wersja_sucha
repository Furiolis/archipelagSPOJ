from math import sqrt
from math import inf
from math import ceil
from fractions import Fraction
from itertools import filterfalse
from itertools import combinations
from time import time


def dlugosc(punkt_a, punkt_b):
    a = b = c = d = 0
    if type(punkt_a) is tuple or type(punkt_a) is list:
        a, b = punkt_a
    elif type(punkt_a) is Baza or type(punkt_a) is Punkt:
        a = punkt_a.x
        b = punkt_a.y
    else:
        print("Blad typu dla punktu_a")

    if type(punkt_b) is tuple or type(punkt_b) is list:
        c, d = punkt_b
    elif type(punkt_b) is Baza or type(punkt_b) is Punkt:
        c = punkt_b.x
        d = punkt_b.y
    else:
        print("Blad typu dla punktu_b")
    dl = sqrt(abs(a - c) ** 2 + abs(b - d) ** 2)

    # print("Dlugosc obliczona dla punktow", a, b, "oraz", c, d, "=", dl)
    return dl


class Punkt:
    def __init__(self, x, y, strefa=None, wyspa=None):
        self.x = x
        self.y = y
        self.strefa = strefa
        self.index = -1
        self.polaczenia = []
        self.wyspa = wyspa

    def drukuj(self, komentarz=""):
        return "Punkt:" + str(self.x) + " " + str(self.y) + " " + komentarz

    def zwroc_polaczenia_do_przetworzenia(self, punkty_przetworzone):
        polaczenia_do_zwrotu = []
        for odcinek in self.polaczenia:
            if (odcinek.punkt_a in punkty_przetworzone) or (odcinek.punkt_b in punkty_przetworzone):
                pass
            else:
                polaczenia_do_zwrotu.append(odcinek)

        print("Polaczenia do zwrtotu")
        for odcinek in polaczenia_do_zwrotu:
            print(odcinek.drukuj(" polaczenie do zwrotu"))
        print("To byly polaczenia do zwrotu")
        return polaczenia_do_zwrotu

    @staticmethod
    def wczytaj_punkt():
        x, y = input().split()
        return Punkt(int(x), int(y))

    def zwroc_nazwe(self):
        return str(self.x) + " " + str(self.y)

    def __eq__(self, punkt):
        # print("porownuje te 2 punkty")
        # print(self.drukuj())
        # print(self.x == punkt.x)
        # print(punkt.drukuj())
        # print(self.y == punkt.y)

        if self.x == punkt.x and self.y == punkt.y:
            # print("sa rowne")
            return True
        else:
            # print("nie sa rowne")
            return False

    def zwroc_lustrzany_punkt(self):
        # Funkcja lustrzany_punkt zwraca punkt ktory jest po przeciwnej stronie strefy wzgledem argumentu
        punkty_strefy = self.strefa.zwroc_punkty()
        if self.strefa is None:
            return None
        elif self == punkty_strefy[0]:
            return punkty_strefy[1]
        elif self == punkty_strefy[1]:
            return punkty_strefy[0]
        elif self == punkty_strefy[2]:
            return punkty_strefy[3]
        elif self == punkty_strefy[3]:
            return punkty_strefy[2]

    def zwroc_punkty_sasiednie(self):
        punkty_strefy = self.strefa.zwroc_punkty()
        lustrzany = self.zwroc_lustrzany_punkt()
        if self.strefa is None:
            return None
        else:
            do_zwrotu = []
            for punkt in punkty_strefy:
                if (not punkt == self) and (not punkt == lustrzany):
                    do_zwrotu.append(punkt)
            return do_zwrotu

    def zwroc_strefe(self):
        return self.strefa


class Baza(Punkt):
    def __init__(self, x, y, nazwa):
        super().__init__(x, y)
        self.nazwa = nazwa
        self.index_globalny = -1
        self.polaczenia_wewnetrzne = []
        self.polaczenia_zewnetrzne = []

    @staticmethod
    def wczytaj_baze():
        nazwa, x, y = input().split()
        return Baza(int(x), int(y), nazwa)

    def zwroc_nazwe(self):
        return self.nazwa

    def drukuj(self, komentarz=""):
        return "Baza:" + str(self.x) + " " + str(self.y) + " " + self.nazwa + " " + komentarz


class Strefa:
    def __init__(self, x1, y1, x2, y2):
        self.x1 = x1
        self.x2 = x2
        self.y1 = y1
        self.y2 = y2
        self.wyspa = None
        self.punkt_a = Punkt(x1, y1, self)
        self.punkt_b = Punkt(x2, y2, self)
        self.punkt_c = Punkt(x1, y2, self)
        self.punkt_d = Punkt(x2, y1, self)

    @staticmethod
    def wczytaj_strefe():
        nazwa, x1, y1, x2, y2 = input().split()
        return Strefa(int(x1), int(y1), int(x2), int(y2))

    def zwroc_punkty(self):
        return [self.punkt_a, self.punkt_b, self.punkt_c, self.punkt_d]

    def drukuj(self, tekst="Drukuje strefe = "):
        print(tekst, self.x1, self.y1, self.x2, self.y2)


class Odcinek:
    def __init__(self, punkt_a, punkt_b, licz_dlugosc=False):
        self.punkt_a = punkt_a
        self.punkt_b = punkt_b
        if (punkt_a.x - punkt_b.x != 0) and (punkt_a.y - punkt_b.y != 0):
            self.a = Fraction((punkt_a.y - punkt_b.y) / (punkt_a.x - punkt_b.x))
            self.b = Fraction(punkt_a.y - self.a * punkt_a.x)
            self.charakter = "skosny"
        elif punkt_a.x == punkt_b.x:
            self.a = punkt_a.x
            self.b = punkt_a.x
            self.charakter = "pionowy"
        elif punkt_a.y == punkt_b.y:
            self.a = punkt_b.y
            self.b = punkt_b.y
            self.charakter = "poziomy"
        if licz_dlugosc:
            self.dystans = dlugosc(punkt_a, punkt_b)
        else:
            self.dystans = 0

    def drukuj(self, komentarz=""):
        return str(self.punkt_a.drukuj()) + " " + str(self.punkt_b.drukuj()) + " dlugosc = " + str(round(self.dlugosc(), 4)) + " " + komentarz

    def dlugosc(self):
        if self.dystans == 0:
            return sqrt(abs(self.punkt_a.x - self.punkt_b.x) ** 2 + abs(self.punkt_a.y - self.punkt_b.y) ** 2)
        else:
            return self.dystans

    def czy_odcinek_przecina_jakies_strefy(self, strefy):
        # Funkcja czy_odcinek_przecina_jakies_strefy na podstawie rowniania prostej(odcinka) stworzonego dzieki rownaniu
        # y=ax+b i punktom oblicza, czy pojawia sie taki punkt w ktorym rownanie y=ax+b zachodzi, z zastrzezeniem
        # ograniczonego obszaru odcinka, nie zas przez caly uklad wspolrzednych.
        # Dodatkowo obsluguje sytuacje kiedy odcinek jest rownolegly do osi x albo osi y.
        # Jeszcze dodatkowo, obslugujemy sytuacje kiedy odcinek staje sie przekontna strefy wykluczenia. Jest to
        # konieczne poniewaz podobna sytacja wystepuje kiedy odcinek(trasa) przechodzi, przez któryś z bokow. Tez dwa
        # wierzcholki sa przeciete ale wtedy nie jest naruszamy strefy.

        # istnieje mozliwa optymalizacja, polegajaca na pierwotnym sprawdzeniu czy strefa jest w ogole w zasiegu odcinka
        # print()
        # print("**********************************")
        # print("Wywolanie czy_odcinek_przecina_jakies_strefy")
        # print(self.punkt_a.drukuj(), " oraz ", self.punkt_b.drukuj())

        if not type(strefy) is list:
            strefy = [strefy]
        for strefa in strefy:
            # strefa.drukuj()
            if self.charakter == "skosny":
                temp1_y = Fraction(self.a * strefa.x1 + self.b)   # potencjalne punkty przeciecia, (strefa.x1, temp1_y)
                temp1_y = temp1_y.limit_denominator(15)
                temp2_y = Fraction(self.a * strefa.x2 + self.b)   # a oraz b sa tutaj wystepujacymi wartosciami w  y = ax + b
                temp2_y = temp2_y.limit_denominator(15)
                temp1_x = Fraction((strefa.y1 - self.b) / self.a)  # potencjalne punkty przeciecia, (temp1_x, strefa.y1)
                temp1_x = temp1_x.limit_denominator(15)
                temp2_x = Fraction((strefa.y2 - self.b) / self.a)
                temp2_x = temp2_x.limit_denominator(15)
                # print("temp1_x = ", temp1_x, "temp1_y = ", temp1_y, "temp2_x", temp2_x, "temp2_y", temp2_y)
                if (strefa.y1 < temp1_y < strefa.y2 or strefa.y1 > temp1_y > strefa.y2) and \
                        (self.punkt_a.x > strefa.x1 > self.punkt_b.x or self.punkt_b.x > strefa.x1 > self.punkt_a.x):
                    # print("Tutaj jestem 1, przeciecie lewej krawedzi")
                    # powyzsza linijka upewnia nas ze strefa jest pomiedzy koncami odcinka, nie zas na jego przedluzeniu
                    return True
                elif (strefa.y1 < temp2_y < strefa.y2 or strefa.y1 > temp2_y > strefa.y2) and \
                        (self.punkt_a.x > strefa.x2 > self.punkt_b.x or self.punkt_b.x > strefa.x2 > self.punkt_a.x):
                    # print("Tutaj jestem 2, przeciecie prawej krawedzi")
                    return True
                elif (strefa.x1 < temp1_x < strefa.x2 or strefa.x1 > temp1_x > strefa.x2) and \
                        (self.punkt_a.y > strefa.y1 > self.punkt_b.y or self.punkt_b.y > strefa.y1 > self.punkt_a.y):
                    # print("Tutaj jestem 3, przeciecie gornej krawedzi")
                    return True
                elif (strefa.x1 < temp2_x < strefa.x2 or strefa.x1 > temp2_x > strefa.x2) and \
                        (self.punkt_a.y > strefa.y2 > self.punkt_b.y or self.punkt_b.y > strefa.y2 > self.punkt_a.y):
                    # print("Tutaj jestem 4, przeciecie dolnej krawedzi")
                    return True
                # tu jest fragment obslugujacy sytuacje gdy odcinek jest przekatna
                elif ((Punkt(temp1_x, temp1_y) == strefa.punkt_a and Punkt(temp2_x, temp2_y) == strefa.punkt_b) or
                      (Punkt(temp2_x, temp2_y) == strefa.punkt_a and Punkt(temp1_x, temp1_y) == strefa.punkt_b)) and \
                        ((self.punkt_a.x <= strefa.x1 and self.punkt_b.x >= strefa.x2) or
                         (self.punkt_a.x >= strefa.x1 and self.punkt_b.x <= strefa.x2)):
                    # print("Tutaj jestem 5, przeciecie malejacej przekatnej")
                    return True
                elif ((Punkt(temp2_x, temp1_y) == strefa.punkt_c and Punkt(temp1_x, temp2_y) == strefa.punkt_d) or
                      (Punkt(temp1_x, temp2_y) == strefa.punkt_c and Punkt(temp2_x, temp1_y) == strefa.punkt_d)) and \
                        ((self.punkt_a.x <= strefa.x1 and self.punkt_b.x >= strefa.x2) or
                         (self.punkt_a.x >= strefa.x1 and self.punkt_b.x <= strefa.x2)):
                    # print("Tutaj jestem 6, przeciecie rosnacej przekatnej")
                    return True
            elif self.charakter == "pionowy":
                if (strefa.x1 < self.a < strefa.x2 or strefa.x1 > self.a > strefa.x2) and \
                        (self.punkt_a.y > strefa.y1 > self.punkt_b.y or self.punkt_b.y > strefa.y1 > self.punkt_a.y):
                    # print("Tutaj jestem 7, pionowe przeciecie")
                    return True
            elif self.charakter == "poziomy":
                if (strefa.y1 < self.a < strefa.y2 or strefa.y1 > self.a > strefa.y2) and \
                        (self.punkt_a.x > strefa.x1 > self.punkt_b.x or self.punkt_b.x > strefa.x1 > self.punkt_a.x):
                    # print("Tutaj jestem 8, poziome przeciecie")
                    return True
        # print(print("#########################################"))
        # print()
        return False


class Polaczenia:
    def __init__(self, baza_1, wyspa_1, baza_2, wyspa_2):
        self.baza_1 = baza_1
        self.baza_2 = baza_2
        self.wyspa_2 = wyspa_2
        self.wyspa_1 = wyspa_1


class Trasa(Polaczenia):
    def __init__(self, punkt_poczatkowy, punkt_docelowy, poprzedzajaca_trasa=None, odcinek=None, dystans=inf):
        super().__init__(punkt_poczatkowy, punkt_poczatkowy.wyspa, punkt_docelowy, punkt_docelowy.wyspa)
        self.punkt_poczatkowy = punkt_poczatkowy
        self.punkt_docelowy = punkt_docelowy
        self.najkrotsza_trasa_do_punktu_docelowego = poprzedzajaca_trasa
        self.odcinek = odcinek
        self.dystans = dystans

    def wyswietl_trase(self):
        if self.punkt_poczatkowy == self.punkt_docelowy:
            print("Punkt poczatkowy, jestem w punkcie wyjsciowym")
        else:
            print("Punkt poczatkowy: {} ".format(self.punkt_poczatkowy.drukuj()))
            print("Punkt docelowy: {} ".format(self.punkt_docelowy.drukuj()))
            print("Droga calkowita {}: ".format(self.dystans))
            if self.najkrotsza_trasa_do_punktu_docelowego is None:
                print("Brak Punktu poprzedzajacego")
            else:
                self.najkrotsza_trasa_do_punktu_docelowego.drukuj_poprzedzajacy_punkt()

    def drukuj_poprzedzajacy_punkt(self):
        if self.punkt_poczatkowy == self.punkt_docelowy:
            print(self.punkt_poczatkowy.drukuj(" !!!!!!!!!!!!!!!!! Punkt poczatkowy"))
        else:
            if self.najkrotsza_trasa_do_punktu_docelowego is None:
                print("Brak Punktu poprzedzajacego")
            else:
                print(self.punkt_docelowy.drukuj(), self.odcinek.dlugosc())
                self.najkrotsza_trasa_do_punktu_docelowego.drukuj_poprzedzajacy_punkt()

    @staticmethod
    def porownaj_trasy_zwroc_optymalniejsza(trasa_pierwsza, trasa_druga):
        # print("Porownuje trasy")
        # print("Trasa numer 1")
        # trasa_pierwsza.wyswietl_trase()
        # print("Trasa numer 2")
        # trasa_druga.wyswietl_trase()
        if trasa_pierwsza.punkt_poczatkowy == trasa_druga.punkt_poczatkowy and trasa_pierwsza.punkt_docelowy == trasa_druga.punkt_docelowy:
            if trasa_pierwsza.dystans > trasa_druga.dystans:
                # print("wybralem trase nr 2")
                return trasa_druga
            elif trasa_pierwsza.dystans < trasa_druga.dystans:
                # print("wybralem trase nr 1")
                return trasa_pierwsza

            elif trasa_pierwsza.dystans == trasa_druga.dystans:
                if trasa_pierwsza.najkrotsza_trasa_do_punktu_docelowego == trasa_druga.najkrotsza_trasa_do_punktu_docelowego:
                    # print("to jest taka sama trasa, mialem taki sam dystans, nie powinno sie wydarzyc, ale i tak zwracam trase pierwsza")
                    return trasa_pierwsza
                else:
                    licznik_1 = 0
                    sprawdzam = False
                    temp_punkt_1 = trasa_pierwsza.najkrotsza_trasa_do_punktu_docelowego
                    temp_punkt_2 = trasa_druga.najkrotsza_trasa_do_punktu_docelowego
                    while not sprawdzam:
                        if temp_punkt_1.najkrotsza_trasa_do_punktu_docelowego is None:
                            sprawdzam = True
                        else:
                            temp_punkt_1 = temp_punkt_1.najkrotsza_trasa_do_punktu_docelowego
                            licznik_1 += 1
                    licznik_2 = 0
                    sprawdzam = False
                    while not sprawdzam:
                        if temp_punkt_2.najkrotsza_trasa_do_punktu_docelowego is None:
                            sprawdzam = True
                        else:
                            temp_punkt_2 = temp_punkt_2.najkrotsza_trasa_do_punktu_docelowego
                            licznik_2 += 1
                    if licznik_1 < licznik_2:
                        # print("wybralem trase nr 1, mialam taki sam dystans")
                        return trasa_pierwsza
                    elif licznik_1 > licznik_2:
                        # print("wybralem trase nr 2, mialem taki sam dystans")
                        return trasa_druga
                    elif licznik_1 == licznik_2:
                        # print("trasy byly podobne, ale i tak wybralem pierwsza")
                        return trasa_druga
        # print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
        # print("Blad porownania trasa, porownywalem rozne trasy")
        # print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")


class PolaczenieMiedzywyspowe(Polaczenia):
    def __init__(self, baza_1, wyspa_1, baza_2, wyspa_2, dystans):
        super().__init__(baza_1, wyspa_1, baza_2, wyspa_2)
        self.dystans = dystans

    @staticmethod
    def wczytaj_dane_polaczenia(wyspy):
        baza_1, wyspa_1, baza_2, wyspa_2, dystans = input().split()
        baza_1_zidentyfikowana = None
        wyspa_1_zidentyfikowana = None
        baza_2_zidentyfikowana = None
        wyspa_2_zidentyfikowana = None
        for wyspa in wyspy:
            if wyspa.nazwa == wyspa_1:
                wyspa_1_zidentyfikowana = wyspa
                for baza in wyspa.bazy:
                    if baza.nazwa == baza_1:
                        baza_1_zidentyfikowana = baza
                        break
            elif wyspa.nazwa == wyspa_2:
                wyspa_2_zidentyfikowana = wyspa
                for baza in wyspa.bazy:
                    if baza.nazwa == baza_2:
                        baza_2_zidentyfikowana = baza
                        break
        baza_1_zidentyfikowana.polaczenia_zewnetrzne.append(
            PolaczenieMiedzywyspowe(baza_1_zidentyfikowana, wyspa_1_zidentyfikowana, baza_2_zidentyfikowana,
                                    wyspa_2_zidentyfikowana, int(dystans)))
        baza_2_zidentyfikowana.polaczenia_zewnetrzne.append(
            PolaczenieMiedzywyspowe(baza_2_zidentyfikowana, wyspa_2_zidentyfikowana, baza_1_zidentyfikowana,
                                    wyspa_1_zidentyfikowana, int(dystans)))

    def wyswietl_trase(self):
        print("Polaczenie miedzywyspowe")
        print("Wyspa bazowa: {}".format(self.wyspa_1.nazwa))
        print(self.baza_1.drukuj())
        print("Wyspa docelowa: {}".format(self.wyspa_2.nazwa))
        print(self.baza_2.drukuj())
        print("Dystans {}".format(self.dystans))


class TrasaGlobalna(Trasa):
    def __init__(self, baza_poczatkowa, baza_docelowa, poprzedzajaca_trasa=None, odcinek=None, dystans=inf):
        super().__init__(baza_poczatkowa, baza_docelowa, poprzedzajaca_trasa, odcinek, dystans)

    def wyswietl_trase(self):
        if self.punkt_poczatkowy == self.punkt_docelowy:
            print("Punkt poczatkowy, jestem w punkcie wyjsciowym")
        else:
            print("Punkt poczatkowy: {} ".format(self.punkt_poczatkowy.drukuj()))
            print("Punkt docelowy: {} ".format(self.punkt_docelowy.drukuj()))
            print("Droga calkowita {}: ".format(self.dystans))
            if self.najkrotsza_trasa_do_punktu_docelowego is None:
                print("Brak Punktu poprzedzajacego")
            else:
                # self.odcinek.wyswietl_trase()
                self.najkrotsza_trasa_do_punktu_docelowego.drukuj_poprzedzajacy_punkt()

    def drukuj_poprzedzajacy_punkt(self):
        if self.punkt_poczatkowy == self.punkt_docelowy:
            print(self.punkt_poczatkowy.drukuj(" !!!!!!!!!!!!!!!!! Punkt poczatkowy"))
        else:
            if self.najkrotsza_trasa_do_punktu_docelowego is None:
                print("Brak Punktu poprzedzajacego")
            else:
                print(self.punkt_docelowy.drukuj(), self.odcinek.dystans)
                # self.odcinek.wyswietl_trase()
                self.najkrotsza_trasa_do_punktu_docelowego.drukuj_poprzedzajacy_punkt()

    @staticmethod
    def porownaj_trasy_zwroc_optymalniejsza(trasa_pierwsza, trasa_druga):
        # print("Porownuje trasy")
        # print("Trasa numer 1")
        # trasa_pierwsza.wyswietl_trase()
        # print("Trasa numer 2")
        # trasa_druga.wyswietl_trase()
        if trasa_pierwsza.punkt_poczatkowy == trasa_druga.punkt_poczatkowy and trasa_pierwsza.punkt_docelowy == trasa_druga.punkt_docelowy:
            if trasa_pierwsza.dystans > trasa_druga.dystans:
                # print("wybralem trase nr 2")
                return trasa_druga
            elif trasa_pierwsza.dystans < trasa_druga.dystans:
                # print("wybralem trase nr 1")
                return trasa_pierwsza
            else:
                # print("Dystans obu tras byl identyczny ale i tak wybralem trase nr 1")
                return trasa_pierwsza


class Wyspa:
    def __init__(self, nazwa, x, y, bazy, strefy):
        self.nazwa = nazwa
        self.x = x
        self.y = y
        self.bazy = bazy
        self.strefy = strefy
        self.polaczenia = []    # sa to polaczenia miedzy punktami na wyspie
        self.polaczenia_miedzywyspowe = []  # sa to polaczenia globalne miedzy bazami
        if len(bazy) > 1:
            for baza in bazy:
                self.wyznacz_droge_wewnatrz_wyspy(baza)

    def zwroc_wszystkie_punkty(self):
        lista_wszystkich_punktow = []
        for baza in self.bazy:
            lista_wszystkich_punktow.append(baza)
        for strefa in self.strefy:
            for punkt in strefa.zwroc_punkty():
                lista_wszystkich_punktow.append(punkt)
        return lista_wszystkich_punktow

    def tworz_liste_polaczen_bezposrednich_wewnatrz_wyspy(self):
        # poczatek = time()
        if not self.polaczenia:
            punkty = self.bazy[:]
            for strefa in self.strefy:
                for punkt in strefa.zwroc_punkty():
                    punkty.append(punkt)
            pary = (filterfalse(lambda para: Odcinek(para[0], para[1]).czy_odcinek_przecina_jakies_strefy(self.strefy), combinations(punkty, 2)))
            self.polaczenia = [Odcinek(para[0], para[1], True) for para in pary]
            for odcinek in self.polaczenia:
                # print(odcinek.drukuj("sprawdzam "))
                if (odcinek.punkt_a.strefa != odcinek.punkt_b.strefa) and (odcinek.punkt_a.strefa is not None) and (
                        odcinek.punkt_a.strefa is not None):
                    # print("Trafilem tutaj 1")
                    odcinek.punkt_a.polaczenia.append(odcinek)
                    # print(odcinek.punkt_a.strefa.drukuj())
                    odcinek.punkt_b.polaczenia.append(odcinek)
                    # print(odcinek.punkt_b.strefa.drukuj())

                elif odcinek.punkt_a.strefa == odcinek.punkt_b.strefa:
                    # print("Trafilem tutaj 2")
                    # print(odcinek.punkt_a.strefa.drukuj())
                    odcinek.punkt_a.polaczenia.append(odcinek)
                    odcinek.punkt_b.polaczenia.append(odcinek)

                elif odcinek.punkt_a.strefa is None and odcinek.punkt_b.strefa is not None:
                    # print("Trafilem tutaj 3")
                    # print(odcinek.punkt_b.strefa.drukuj())
                    odcinek.punkt_b.polaczenia.append(odcinek)
                    odcinek.punkt_a.polaczenia.append(odcinek)

                elif odcinek.punkt_b.strefa is None and odcinek.punkt_a.strefa is not None:
                    # print("Trafilem tutaj 4")
                    # print(odcinek.punkt_a.strefa.drukuj())
                    odcinek.punkt_a.strefa.polaczenia.append(odcinek)
                    odcinek.punkt_b.polaczenia.append(odcinek)
        # print("Czas algorytmu tworzenia odcikow to: ", time() - poczatek)
        return self.polaczenia

    @staticmethod
    def wyznacz_droge(wyspy, trasa):
        baza_1, wyspa_1, baza_2, wyspa_2 = trasa
        baza_1_zidentyfikowana = None
        baza_2_zidentyfikowana = None
        for wyspa in wyspy:
            if wyspa.nazwa == wyspa_1:
                for baza in wyspa.bazy:
                    if baza.nazwa == baza_1:
                        baza_1_zidentyfikowana = baza
                        break
            elif wyspa.nazwa == wyspa_2:
                for baza in wyspa.bazy:
                    if baza.nazwa == baza_2:
                        baza_2_zidentyfikowana = baza
                        break
        polaczenie = Wyspa.wyznacz_droge_miedzy_wyspami(wyspy, baza_1_zidentyfikowana, baza_2_zidentyfikowana)
        polaczenie.wyswietl_trase()

    @staticmethod
    def wyznacz_droge_miedzy_wyspami(wyspy, baza_poczatkowa, baza_docelowa):
        # poczatek = time()
        bazy_wszystkie_do_przetworzenia = []
        lista_polaczen_globalnych = []
        for wyspa in wyspy:
            bazy_wszystkie_do_przetworzenia += wyspa.bazy
        for index, baza in enumerate(bazy_wszystkie_do_przetworzenia):
            lista_polaczen_globalnych.append(TrasaGlobalna(baza_poczatkowa, baza))
            baza.index_globalny = index
        lista_polaczen_globalnych[baza_poczatkowa.index_globalny].dystans = 0
        bazy_przetworzone = []
        bazy_do_przetworzenia_w_nastepnej_kolejce = [baza_poczatkowa]
        while bazy_do_przetworzenia_w_nastepnej_kolejce:
            biezace_bazy_do_przetworzenia = sorted(bazy_do_przetworzenia_w_nastepnej_kolejce, key=lambda x: lista_polaczen_globalnych[x.index_globalny].dystans)
            bazy_do_przetworzenia_w_nastepnej_kolejce = []
            for baza in biezace_bazy_do_przetworzenia:
                # print("kolejny obieg for")
                # print(baza.drukuj())
                polaczenia_do_przetworzenia = baza.polaczenia_wewnetrzne + baza.polaczenia_zewnetrzne
                for polaczenie in polaczenia_do_przetworzenia:
                    # polaczenie.wyswietl_trase()
                    # print("ja sie wyswietlam")
                    # print(lista_polaczen_globalnych[baza.index_globalny].dystans, " trasa dotychczasowa")
                    # print("ja sie wyswietlam tez")
                    # print(polaczenie.dystans, " dystans biezacego polaczenia")
                    if polaczenie.baza_1 == baza:
                        baza_posrednia = polaczenie.baza_2
                    else:  # polaczenie.baza_2 == baza:
                        baza_posrednia = polaczenie.baza_1
                    trasa = TrasaGlobalna(baza_poczatkowa, baza_posrednia, lista_polaczen_globalnych[baza.index_globalny], polaczenie,
                                          lista_polaczen_globalnych[baza.index_globalny].dystans + polaczenie.dystans)
                    lista_polaczen_globalnych[baza_posrednia.index_globalny] = TrasaGlobalna.porownaj_trasy_zwroc_optymalniejsza(trasa, lista_polaczen_globalnych[baza_posrednia.index_globalny])
                    if (baza_posrednia not in bazy_do_przetworzenia_w_nastepnej_kolejce) and (baza_posrednia not in bazy_przetworzone):
                        bazy_do_przetworzenia_w_nastepnej_kolejce.append(baza_posrednia)
            nowa_lista_baz_wszystkich = []
            for baza_do_przekazania in bazy_wszystkie_do_przetworzenia:
                if baza_do_przekazania not in biezace_bazy_do_przetworzenia:
                    nowa_lista_baz_wszystkich.append(baza_do_przekazania)
                else:
                    bazy_przetworzone.append(baza_do_przekazania)
            bazy_wszystkie_do_przetworzenia = nowa_lista_baz_wszystkich
        # print("Czas znajdowania drogi to: ", time() - poczatek)
        return lista_polaczen_globalnych[baza_docelowa.index_globalny]

    def wyznacz_droge_wewnatrz_wyspy(self, punkt_bazowy):  # punkt_docelowy=None
        # odcinek = Odcinek(punkt_bazowy, punkt_docelowy, True)
        # if not odcinek.czy_odcinek_przecina_jakies_strefy(self.strefy):
        #     trasa = Trasa(punkt_bazowy, punkt_docelowy, None, odcinek, odcinek.dlugosc())
        #     return [trasa]
        # else:
        self.tworz_liste_polaczen_bezposrednich_wewnatrz_wyspy()
        # poczatek = time()
        lista_polaczen_posrednich = []
        punkty_wszystkie_do_przetworzenia = self.zwroc_wszystkie_punkty()
        for index, punkt in enumerate(punkty_wszystkie_do_przetworzenia):
            lista_polaczen_posrednich.append(Trasa(punkt_bazowy, punkt))
            # print(punkt.drukuj() + " index " + str(index))
            punkt.index = index
            # lista_polaczen_posrednich[index].wyswietl_trase()

        lista_polaczen_posrednich[punkt_bazowy.index].dystans = 0
        # del punkty_wszystkie_do_przetworzenia[punkty_wszystkie_do_przetworzenia.index(punkt_bazowy)]

        punkty_przetworzone = []
        punkty_do_przetworzenia_w_nastepnej_kolejce = [punkt_bazowy]
        # while (len(punkty_wszystkie_do_przetworzenia) != 1) and (punkt_docelowy in punkty_wszystkie_do_przetworzenia):
        while punkty_do_przetworzenia_w_nastepnej_kolejce:
            # print("kolejny obieg while")
            # print("punkty do przetworzenia w tej kolejce")
            # for punkt in punkty_do_przetworzenia_w_nastepnej_kolejce:
            # print(punkt.drukuj())
            biezace_punkty_do_przetworzenia = sorted(punkty_do_przetworzenia_w_nastepnej_kolejce, key=lambda x: lista_polaczen_posrednich[x.index].dystans)
            punkty_do_przetworzenia_w_nastepnej_kolejce = []
            for punkt in biezace_punkty_do_przetworzenia:
                # print("kolejny obieg for")
                polaczenia_do_przetworzenia = punkt.polaczenia  # usunalem stad punkty_przetworzone

                for polaczenie in polaczenia_do_przetworzenia:
                    # print(polaczenie.drukuj())
                    if polaczenie.punkt_a == punkt:
                        punkt_posredni = polaczenie.punkt_b
                    else:  # polaczenie.punkt_b == punkt:
                        punkt_posredni = polaczenie.punkt_a

                    trasa = Trasa(punkt_bazowy, punkt_posredni, lista_polaczen_posrednich[punkt.index], polaczenie,
                                  lista_polaczen_posrednich[punkt.index].dystans + polaczenie.dlugosc())
                    lista_polaczen_posrednich[punkt_posredni.index] = Trasa.porownaj_trasy_zwroc_optymalniejsza(trasa, lista_polaczen_posrednich[punkt_posredni.index])
                    if (punkt_posredni not in punkty_do_przetworzenia_w_nastepnej_kolejce) and (punkt_posredni not in punkty_przetworzone):
                        punkty_do_przetworzenia_w_nastepnej_kolejce.append(punkt_posredni)
            # print("punkty do przetworzenia w nastepnej kolejce")
            # for punktttt in punkty_do_przetworzenia_w_nastepnej_kolejce:
            #    print(punktttt.drukuj())
            nowa_lista_punktow_wszystkich = []
            for punkt_do_przekazania in punkty_wszystkie_do_przetworzenia:
                if punkt_do_przekazania not in biezace_punkty_do_przetworzenia:
                    nowa_lista_punktow_wszystkich.append(punkt_do_przekazania)
                else:
                    # print(punkt_do_przekazania.drukuj(" usunalem ten punkt"))
                    punkty_przetworzone.append(punkt_do_przekazania)
            punkty_wszystkie_do_przetworzenia = nowa_lista_punktow_wszystkich
            # sortuj kolekce
            # for punkt in punkty_wszystkie_do_przetworzenia:
            #     print(punkt.drukuj(" punkty do przetworzenia pozostale"))
        # print("Czas znajdowania drogi to: ", time() - poczatek)

        for baza in self.bazy:
            lista_polaczen_posrednich[baza.index].dystans = ceil(lista_polaczen_posrednich[baza.index].dystans)
            punkt_bazowy.polaczenia_wewnetrzne.append(lista_polaczen_posrednich[baza.index])
        return lista_polaczen_posrednich   # usunalem dopisek: [punkt_docelowy.index]

    @staticmethod
    def wczytaj_dane_wyspy():
        nazwa_wyspy = input()
        wymiarx, wymiary = input().split()

        liczba_baz = int(input())
        bazy = []
        while liczba_baz > 0:
            nazwa_bazy, x, y = input().split()
            liczba_baz -= 1
            bazy.append(Baza(int(x), int(y), nazwa_bazy))

        liczba_stref = int(input())
        strefy = []
        while liczba_stref > 0:
            x1, y1, x2, y2 = input().split()
            liczba_stref -= 1
            strefy.append(Strefa(int(x1), int(y1), int(x2), int(y2)))
        wyspa = Wyspa(nazwa_wyspy, int(wymiarx), int(wymiary), bazy, strefy)
        for baza in wyspa.bazy:
            baza.wyspa = wyspa
        for strefa in wyspa.strefy:
            strefa.wyspa = wyspa
            strefa.punkt_a.wyspa = wyspa
            strefa.punkt_b.wyspa = wyspa
            strefa.punkt_c.wyspa = wyspa
            strefa.punkt_d.wyspa = wyspa
        return wyspa


def main():
    liczba_przypadkow = int(input())
    poczatek = time()
    while liczba_przypadkow > 0:
        liczba_wysp = int(input())
        wyspy = []
        while liczba_wysp > 0:
            wyspy.append(Wyspa.wczytaj_dane_wyspy())
            liczba_wysp -= 1
        liczba_polaczen = int(input())
        while liczba_polaczen > 0:
            PolaczenieMiedzywyspowe.wczytaj_dane_polaczenia(wyspy)
            liczba_polaczen -= 1
        trasa_do_pokonania = input().split()
        print(trasa_do_pokonania)

        # for iii in wyspy[2].bazy[0].polaczenia_wewnetrzne:
        #     iii.wyswietl_trase()
        Wyspa.wyznacz_droge(wyspy, trasa_do_pokonania)
        # polaczenia = wyspy[8].wyznacz_droge_wewnatrz_wyspy(wyspy[8].bazy[2])   # wyspy[0].bazy[1]
        print()
        print("UWAGA UWAGA")
        # for polaczenie in polaczenia:

        # polaczenie.wyswietl_trase()

        print()
        # dupa jak supa
        # print("polaczenie wewnetrzne")
        # for polaczenie in wyspy[0].bazy[2].polaczenia_wewnetrzne:
        #     polaczenie.wyswietl_trase()
        # print("polaczenia zewnetrzne")
        # for polaczenie in wyspy[0].bazy[2].polaczenia_zewnetrzne:
        #     polaczenie.wyswietl_trase()

        # for polaczenie in wyspy[0].polaczenia_miedzybazowe:
        #     polaczenie.drukuj()
        # for trasa in wyspy[0].altualna_przeliczona_trasa:
        #     trasa.wyswietl_trase()
        #     print()
        # for trasa in polaczenia:
        #    trasa.wyswietl_trase()
        #    print()
        # for punkt in wyspy[0].zwroc_wszystkie_punkty():
        #    print(punkt.drukuj())
        # for odcinek in wyspy[0].polaczenia:
        #     print(odcinek.drukuj())

        # print(Odcinek(wyspy[0].bazy[0], wyspy[0].bazy[4]).czy_odcinek_przecina_jakies_strefy(wyspy[0].strefy[26]))
        # print(Odcinek(Punkt(2, 23), Punkt(51, 23)).dlugosc())
        # print(Odcinek(Punkt(2, 23), Punkt(51, 23)).czy_odcinek_przecina_jakies_strefy(wyspy[0].strefy[0]))

        liczba_przypadkow -= 1
    print("Calkowity czas przeliczania to: ", time() - poczatek)


if __name__ == "__main__":
    main()
