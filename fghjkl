
    def czy_odcinek_przecina_jakies_strefy(self, strefy):
        # Funkcja czy_odcinek_przecina_jakies_strefy na podstawie rowniania prostej(odcinka) stworzonego dzieki rownaniu
        # y=ax+b i punktom oblicza, czy pojawia sie taki punkt w ktorym rownanie y=ax+b zachodzi, z zastrzezeniem
        # ograniczonego obszaru odcinka, nie zas przez caly uklad wspolrzednych.
        # Dodatkowo obsluguje sytuacje kiedy odcinek jest rownolegly do osi x albo osi y.
        # Jeszcze dodatkowo, obslugujemy sytuacje kiedy odcinek staje sie przekontna strefy wykluczenia. Jest to
        # konieczne poniewaz podobna sytacja wystepuje kiedy odcinek(trasa) przechodzi, przez któryś z bokow. Tez dwa
        # wierzcholki sa przeciete ale wtedy nie jest naruszamy strefy.

        if not type(strefy) is list:
            strefy = [strefy]

        for strefa in strefy:
            if self.charakter == "skosny":
                temp1_y = self.a * strefa.x1 + self.b  # potencjalne punkty przeciecia, (strefa.x1, temp1_y
                temp2_y = self.a * strefa.x2 + self.b  # a oraz b sa tutaj wystepujacymi wartosciami w  y = ax + b
                temp1_x = (strefa.y1 - self.b) / self.a  # potencjalne punkty przeciecia, (temp1_x, strefa.y1)
                temp2_x = (strefa.y2 - self.b) / self.a
                if ((strefa.y1 < temp1_y < strefa.y2 or strefa.y1 > temp1_y > strefa.y2) and
                        (self.punkt_a.x > strefa.x1 > self.punkt_b.x or self.punkt_b.x > strefa.x1 > self.punkt_a.x)):
                    return True
                elif ((strefa.y1 < temp2_y < strefa.y2 or strefa.y1 > temp2_y > strefa.y2) and
                      (self.punkt_a.x > strefa.x2 > self.punkt_b.x or self.punkt_b.x > strefa.x2 > self.punkt_a.x)):
                    return True
                elif ((strefa.x1 < temp1_x < strefa.x2 or strefa.x1 > temp1_x > strefa.x2) and
                      (self.punkt_a.y > strefa.y1 > self.punkt_b.y or self.punkt_b.y > strefa.y1 > self.punkt_a.y)):
                    return True
                elif ((strefa.x1 < temp2_x < strefa.x2 or strefa.x1 > temp2_x > strefa.x2) and
                      (self.punkt_a.y > strefa.y2 > self.punkt_b.y or self.punkt_b.y > strefa.y2 > self.punkt_a.y)):
                    return True
                # tu jest fragment obslugujacy sytuacje gdy odcinek jest przekatna
                elif (((Wierzcholek(temp1_x, temp1_y, strefa, strefa.wyspa) == strefa.punkt_a and
                        Wierzcholek(temp2_x, temp2_y, strefa, strefa.wyspa) == strefa.punkt_b) or
                       (Wierzcholek(temp2_x, temp2_y, strefa, strefa.wyspa) == strefa.punkt_a and
                        Wierzcholek(temp1_x, temp1_y, strefa, strefa.wyspa) == strefa.punkt_b)) and
                      ((self.punkt_a.x <= strefa.x1 and self.punkt_b.x >= strefa.x2) or
                       (self.punkt_a.x >= strefa.x1 and self.punkt_b.x <= strefa.x2))):
                    return True
                elif (((Wierzcholek(temp2_x, temp1_y, strefa, strefa.wyspa) == strefa.punkt_c and
                        Wierzcholek(temp1_x, temp2_y, strefa, strefa.wyspa) == strefa.punkt_d) or
                       (Wierzcholek(temp1_x, temp2_y, strefa, strefa.wyspa) == strefa.punkt_c and
                        Wierzcholek(temp2_x, temp1_y, strefa, strefa.wyspa) == strefa.punkt_d)) and
                      ((self.punkt_a.x <= strefa.x1 and self.punkt_b.x >= strefa.x2) or
                       (self.punkt_a.x >= strefa.x1 and self.punkt_b.x <= strefa.x2))):
                    return True
            elif self.charakter == "pionowy":
                if (strefa.x1 < self.a < strefa.x2 or strefa.x1 > self.a > strefa.x2) and (
                        self.punkt_a.y > strefa.y1 > self.punkt_b.y or self.punkt_b.y > strefa.y1 > self.punkt_a.y):
                    return True
            elif self.charakter == "poziomy":
                if (strefa.y1 < self.a < strefa.y2 or strefa.y1 > self.a > strefa.y2) and (
                        self.punkt_a.x > strefa.x1 > self.punkt_b.x or self.punkt_b.x > strefa.x1 > self.punkt_a.x):
                    return True
        return False



